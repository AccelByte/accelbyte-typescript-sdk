/*
 * Copyright (c) 2022-2024 AccelByte Inc. All Rights Reserved
 * This is licensed software from AccelByte Inc, for limitations
 * and restrictions contact your company contract manager.
 */
/**
 * AUTO GENERATED
 */
import { CodeGenUtil, IResponse, IResponseWithSync, SDKRequestConfig, SdkCache, Validate } from '@accelbyte/sdk'
import { AxiosInstance } from 'axios'
import { z } from 'zod'
import { CreatePartyRequest } from '../../generated-definitions/CreatePartyRequest.js'
import { JoinByCodeRequest } from '../../generated-definitions/JoinByCodeRequest.js'
import { KickResponse } from '../../generated-definitions/KickResponse.js'
import { PartyQueryResponse } from '../../generated-definitions/PartyQueryResponse.js'
import { PartySessionResponse } from '../../generated-definitions/PartySessionResponse.js'
import { PromoteLeaderRequest } from '../../generated-definitions/PromoteLeaderRequest.js'
import { SessionInviteRequest } from '../../generated-definitions/SessionInviteRequest.js'
import { SessionInviteResponse } from '../../generated-definitions/SessionInviteResponse.js'
import { UpdatePartyRequest } from '../../generated-definitions/UpdatePartyRequest.js'

export class Party$ {
  // @ts-ignore
  constructor(private axiosInstance: AxiosInstance, private namespace: string, private cache = false, private isValidationEnabled = true) {}

  /**
   * A join code will be autogenerated if the party is joinable. Creator will be removed from previous party (if any) and automatically join into the created party as a leader. Party members will be sent invitation to join the party. Session configuration name is optional. Default configuration name if empty: { &#34;name&#34;: &#34;default&#34;, &#34;type&#34;: &#34;NONE&#34;, &#34;joinability&#34;: &#34;OPEN&#34;, &#34;minPlayers&#34;: 1, &#34;maxPlayers&#34;: 8, &#34;inviteTimeout&#34;: 60, &#34;inactiveTimeout&#34;: 60, &#34;textChat&#34;: false } Supported platforms: 1. STEAM 2. PSN 3. XBOX Reserved attributes key: 1. preference: used to store preference of the leader and it is non-replaceable to keep the initial behavior of the session regardless the leader changes. 2. NATIVESESSIONTITLE: used for session sync, to define name of session displayed on PlayStation system UI.
   */
  createParty(data: CreatePartyRequest): Promise<IResponse<PartySessionResponse>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/party'.replace('{namespace}', this.namespace)
    const resultPromise = this.axiosInstance.post(url, data, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, PartySessionResponse, 'PartySessionResponse')
      : Validate.unsafeResponse(() => resultPromise)
  }

  /**
   * Query user&#39;s parties. By default, API will return a list of user&#39;s active parties.
   */
  getUsersMeParties(queryParams?: {
    order?: string | null
    orderBy?: string | null
    status?: string | null
  }): Promise<IResponseWithSync<PartyQueryResponse>> {
    const params = { ...queryParams } as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/users/me/parties'.replace('{namespace}', this.namespace)
    const resultPromise = this.axiosInstance.get(url, { params })

    const res = () =>
      this.isValidationEnabled
        ? Validate.responseType(() => resultPromise, PartyQueryResponse, 'PartyQueryResponse')
        : Validate.unsafeResponse(() => resultPromise)

    if (!this.cache) {
      return SdkCache.withoutCache(res)
    }
    const cacheKey = url + CodeGenUtil.hashCode(JSON.stringify({ params }))
    return SdkCache.withCache(cacheKey, res)
  }

  /**
   * Get party details.
   */
  getParty_ByPartyId(partyId: string): Promise<IResponseWithSync<PartySessionResponse>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/{partyId}'
      .replace('{namespace}', this.namespace)
      .replace('{partyId}', partyId)
    const resultPromise = this.axiosInstance.get(url, { params })

    const res = () =>
      this.isValidationEnabled
        ? Validate.responseType(() => resultPromise, PartySessionResponse, 'PartySessionResponse')
        : Validate.unsafeResponse(() => resultPromise)

    if (!this.cache) {
      return SdkCache.withoutCache(res)
    }
    const cacheKey = url + CodeGenUtil.hashCode(JSON.stringify({ params }))
    return SdkCache.withCache(cacheKey, res)
  }

  /**
   * Update specified fields from party data. Note: Join type can only be updated by the party&#39;s leader. Reserved attributes key: 1. preference: used to store preference of the leader and it is non-replaceable to keep the initial behavior of the session regardless the leader changes. 2. NATIVESESSIONTITLE: used for session sync, to define name of session displayed on PlayStation system UI.
   */
  patchParty_ByPartyId(partyId: string, data: UpdatePartyRequest): Promise<IResponse<PartySessionResponse>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/{partyId}'
      .replace('{namespace}', this.namespace)
      .replace('{partyId}', partyId)
    const resultPromise = this.axiosInstance.patch(url, data, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, PartySessionResponse, 'PartySessionResponse')
      : Validate.unsafeResponse(() => resultPromise)
  }

  /**
   * Updates party blob, this endpoint will override stored party data. Join type can only be updated by the party&#39;s leader. To update only specified fields, please use following endpoint: method : PATCH API : /session/v1/public/namespaces/{namespace}/gamesessions/{sessionId} Reserved attributes key: 1. preference: used to store preference of the leader and it is non-replaceable to keep the initial behavior of the session regardless the leader changes. 2. NATIVESESSIONTITLE: used for session sync, to define name of session displayed on PlayStation system UI.
   */
  updateParty_ByPartyId(partyId: string, data: UpdatePartyRequest): Promise<IResponse<PartySessionResponse>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/{partyId}'
      .replace('{namespace}', this.namespace)
      .replace('{partyId}', partyId)
    const resultPromise = this.axiosInstance.put(url, data, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, PartySessionResponse, 'PartySessionResponse')
      : Validate.unsafeResponse(() => resultPromise)
  }

  /**
   * Revoke code of the party. Only leader can revoke a code.
   */
  deleteCode_ByPartyId(partyId: string): Promise<IResponse<unknown>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/{partyId}/code'
      .replace('{namespace}', this.namespace)
      .replace('{partyId}', partyId)
    const resultPromise = this.axiosInstance.delete(url, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, z.unknown(), 'z.unknown()')
      : Validate.unsafeResponse(() => resultPromise)
  }

  /**
   * Generate a new code for the party. Only leader can generate a code.
   */
  createCode_ByPartyId(partyId: string): Promise<IResponse<PartySessionResponse>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/{partyId}/code'
      .replace('{namespace}', this.namespace)
      .replace('{partyId}', partyId)
    const resultPromise = this.axiosInstance.post(url, null, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, PartySessionResponse, 'PartySessionResponse')
      : Validate.unsafeResponse(() => resultPromise)
  }

  /**
   * Invite a user to a party. platformID represents the native platform of the invitee. API will return the corresponding native platform&#39;s userID. supported platforms: - STEAM - XBOX - PSN
   */
  createInvite_ByPartyId(partyId: string, data: SessionInviteRequest): Promise<IResponse<SessionInviteResponse>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/{partyId}/invite'
      .replace('{namespace}', this.namespace)
      .replace('{partyId}', partyId)
    const resultPromise = this.axiosInstance.post(url, data, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, SessionInviteResponse, 'SessionInviteResponse')
      : Validate.unsafeResponse(() => resultPromise)
  }

  /**
   * Promotes a party member to be a party leader. Only leader can promote a new leader.
   */
  createLeader_ByPartyId(partyId: string, data: PromoteLeaderRequest): Promise<IResponse<PartySessionResponse>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/{partyId}/leader'
      .replace('{namespace}', this.namespace)
      .replace('{partyId}', partyId)
    const resultPromise = this.axiosInstance.post(url, data, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, PartySessionResponse, 'PartySessionResponse')
      : Validate.unsafeResponse(() => resultPromise)
  }

  /**
   * Join a party by code. The user can join a party as long as the code is valid
   */
  createPartyUserMeJoinCode(data: JoinByCodeRequest): Promise<IResponse<PartySessionResponse>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/users/me/join/code'.replace('{namespace}', this.namespace)
    const resultPromise = this.axiosInstance.post(url, data, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, PartySessionResponse, 'PartySessionResponse')
      : Validate.unsafeResponse(() => resultPromise)
  }

  /**
   * Join a party. The user can either join a party they have been invited to, or any party with an &#34;open&#34; joinable setting.
   */
  createUserMeJoin_ByPartyId(partyId: string): Promise<IResponse<PartySessionResponse>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/{partyId}/users/me/join'
      .replace('{namespace}', this.namespace)
      .replace('{partyId}', partyId)
    const resultPromise = this.axiosInstance.post(url, null, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, PartySessionResponse, 'PartySessionResponse')
      : Validate.unsafeResponse(() => resultPromise)
  }

  /**
   * Leave a party
   */
  deleteUserMeLeave_ByPartyId(partyId: string): Promise<IResponse<unknown>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/{partyId}/users/me/leave'
      .replace('{namespace}', this.namespace)
      .replace('{partyId}', partyId)
    const resultPromise = this.axiosInstance.delete(url, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, z.unknown(), 'z.unknown()')
      : Validate.unsafeResponse(() => resultPromise)
  }

  /**
   * Reject a party invitation.
   */
  deleteUserMeReject_ByPartyId(partyId: string): Promise<IResponse<unknown>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/{partyId}/users/me/reject'
      .replace('{namespace}', this.namespace)
      .replace('{partyId}', partyId)
    const resultPromise = this.axiosInstance.delete(url, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, z.unknown(), 'z.unknown()')
      : Validate.unsafeResponse(() => resultPromise)
  }

  /**
   * Kick a player from a party. Requires invoker to be the party leader.
   */
  deleteKick_ByPartyId_ByUserId(partyId: string, userId: string): Promise<IResponse<KickResponse>> {
    const params = {} as SDKRequestConfig
    const url = '/session/v1/public/namespaces/{namespace}/parties/{partyId}/users/{userId}/kick'
      .replace('{namespace}', this.namespace)
      .replace('{partyId}', partyId)
      .replace('{userId}', userId)
    const resultPromise = this.axiosInstance.delete(url, { params })

    return this.isValidationEnabled
      ? Validate.responseType(() => resultPromise, KickResponse, 'KickResponse')
      : Validate.unsafeResponse(() => resultPromise)
  }
}
